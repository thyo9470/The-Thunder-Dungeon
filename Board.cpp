#include<iostream>

#include<vector>
#include<algorithm>
#include<stdlib.h>

#include "Board.h"

/*
  Convert a given TileType to a string

  @param  (TileType) tile - The tile you want the type of in a string
  @return (string)        - The tile type as a string 
*/
std::string TileTypeToString(TileType tile){
  int test = static_cast<int>(tile);
  switch(test){
    case 0:
      return "Empty";
    case 1:
      return "Wall";
    case 2:
      return "Player";
    case 3:
      return "Enemy";
    default:
      return "UNKNOWN";
  }
}


/*

  Creates a board with a given amount of layers with given dimensions

  @param  (int) layers - The number of rendering layers needed
          (int) width - Number of rooms wide the dungeon is
          (int) height - Number of rooms high the dungeon is
*/
Board::Board(int layers, int width, int height){
 
  layers_ = layers;

  width_ = width;
  height_ = height;

  width_res_ = width * 6 + 1;
  height_res_ = height * 6 + 1;
 
  std::vector< std::vector<TileType> > blank_board;
 
  for(int i = 0; i < height_res_; i++){
    std::vector<TileType> blank_row(width_res_, TileType::Empty);
    blank_board.push_back( blank_row );
  }

  std::vector< std::vector< std::vector<TileType> > > temp_board(layers, blank_board);

  board_ = temp_board;

}

/*
    Creates the Dungeon using a modified maze generation algorithm

    The Dungeon is generated by first using a temporary dungeon which assumes that each room is only 1x1. It then generates a maze using thise. Once the maze is generated it's transfered to the actual dungeon and rooms are added
*/
void Board::GenerateDungeon(){
  
  /*
     -------------------------------------------
      Part 1 - Setup for simple Maze generation
     -------------------------------------------
  */

  std::vector< std::vector<TileType> > dungeon;

  int temp_width = width_*2+1;
  int temp_height = height_*2+1;
 
  for(int i = 0; i < temp_height; i++){
    std::vector<TileType> blank_row(temp_width, TileType::Empty);
    dungeon.push_back( blank_row );
  }
  /*
     -------------------------------------------
      Part 2 - Generate maze using radnom Kruskel's algorithm
     -------------------------------------------
  */

  // stores all walls seperating two empty cells(rooms)
  std::vector<Position> walls;

  // stores the cells that are connected in sets
  // every cell will start in its own set
  std::vector< std::vector<Position> > cells;

  // create empty cells and populate walls and cells vector
  for(int x = 0; x < temp_width; x++){
    for(int y = 0; y < temp_height; y++){

      if( (x%2 == 0) || (y%2 == 0) ){
        dungeon[y][x] = TileType::Wall;
        // check if wall is not a perimeter wall
        if( x != 0 && y != 0 && x+1 != temp_width && y+1 != temp_height && ((x%2 == 0) != (y%2 == 0))){
          Position wall_pos(x,y);
          walls.push_back(wall_pos);
        }
      }else{
        std::vector<Position> cell_set;
        Position cell_pos(x, y);
        cell_set.push_back(cell_pos);
        cells.push_back(cell_set);
      }

    } 
  }
  
  // shuffle the walls for randomness
  std::random_shuffle(walls.begin(), walls.end());

  for(auto w : walls){
    std::cout << "(" << w.x_ << ", " << w.y_ << ")";
  }

  std::cout << std::endl;

  // while we still ahve walls to check
  while(walls.size()){

	  Position cur = walls.back();
	
	  bool side = true;
	  if(cur.y_%2 == 0){
	    side = false;
	  } 
	
	  Position cell1;
	  Position cell2;
	
	  // get the cells that the current wall seperate
	  if(side){
	    cell1.x_ = cur.x_ - 1;
	    cell1.y_ = cur.y_;
	
	    cell2.x_ = cur.x_ + 1;
	    cell2.y_ = cur.y_;
	  }else{
	    cell1.x_ = cur.x_;
	    cell1.y_ = cur.y_ - 1;
	
	    cell2.x_ = cur.x_;
	    cell2.y_ = cur.y_ + 1;
	  } 

    int cell1_place;
    int cell2_place;

	  for(unsigned int i = 0; i < cells.size(); i++){
	    if( std::find(cells[i].begin(), cells[i].end(), cell1) != cells[i].end() ){
	      cell1_place = i;
	    } 
	    if( std::find(cells[i].begin(), cells[i].end(), cell2) != cells[i].end() ){
	      cell2_place = i;
	    } 
	  }  

    // if the two cells are not in the same set
    if(cell1_place != cell2_place){
      
      // set wall to empty to connect cells
      dungeon[cur.y_][cur.x_] = TileType::Empty;       

      // store the vector cell2 in a temp value for clean code
      std::vector<Position> cell2_set = cells[cell2_place];

      // combine cell1 and cell2's sets
      cells[cell1_place].insert( cells[cell1_place].end(), cell2_set.begin(), cell2_set.end() );

      // free memory of values in cell2_set
      cells[cell2_place].clear();

      // remove cell2's vector from cells
      cells.erase( cells.begin() + cell2_place );

    } 
    
	
	  walls.pop_back();
	}  
	
  walls.clear();
  cells.clear();	












  for(int x = 0; x < temp_width; x++){
    for(int y = 0; y < temp_height; y++){
      int current = static_cast<int>(dungeon[y][x]);
      switch(current){
        case 0:
          std::cout << " ";
          break;
        case 1:
          std::cout << "â–ˆ";
          break;
      }
    } 
    std::cout << std::endl;
  }

}

/*
  TEST FUNCTION NOT TO KEEP

  Print the board in a visually pleasing way
*/
void Board::PrintBoard(){

  std::cout << "Thunder Dungeon" <<std::endl;


  for(int x = 0; x < width_res_; x++){
    for(int y = 0; y < height_res_; y++){
      std::cout << static_cast<int>(board_[0][y][x]) << " ";
    } 
    std::cout << std::endl;
  }

}
